//
// Created by Administrator on 2019/4/21.
//

#include <stdio.h>
/**
 * cpu运行原理大概说明
 * 计算机所有的数据都保存在内存【在运行的时候会加载到内存】
 * 内存：由大量的寄存器构成
 * 寄存器：由大量的触发器构成
 * 触发器：由大量的门电路【逻辑门电路】构成，一个触发器具有记忆一位二进制的能力
 * 门电路：由大量的电子元件构成【集成芯片】构成大规模的逻辑门电路，如与门，或，非，与非，与或，与或非，异或门等
 * 门电路的构成完成了大量的逻辑信号处理
 * 具备开发功能的电子元件：二极管，三极管，CMOS管，开为高电平，关为低电平逻辑状态为1和0
 * 电子元件的材料：硅，锗
 * 导电特性：半导体，输入不同的电压使元件输出不同的结果如三极具有截止【关】，饱和【关】的功能
 * 数字电路的分析：借助逻辑函数，逻辑表达式，逻辑代数，逻辑图，逻辑电路等
 *
 * 数字电路分类：组合逻辑电路，时序逻辑电路【具有记忆功能】
 * 数字电路能完成的功能：逻辑运算，移位，算术运算，编码，译码等
 *
 * CPU[ALU+寄存器组+状态寄存器等】
 * cpu从内存【指令或叫程序寄存器里取出指令/程序二进制1为高电平0为低电平】，取出的指令输入到
 * 指令寄存器里【寄存器具有存储二进制的功能，如RS触发器】，指令译码器【如3/8译码器，4/16译码器就是将
 * 输入的二进制信号转换为多位的二进制，如000得到00000000 001得到00000001 这种玩意】
 * 指令译码器电路运行后得到结果
 *
 * 译码器译码的二进制信号会传输到【会送ALU（ALU具有逻辑运算的电路，由大量的逻辑门电路构成）】ALU逻辑电路进行处理
 * 处理的结果会保存在状态寄存器【结果】会写到内存
 *
 * 而指令寄存器和数据寄存器【通用计算机就一根内存条保存】单片机单独装，有自己的寻址总线
 *
 * 总线：数据总线，控制总线，控制总线
 *
 *
 * cpu在时钟脉冲电路【时钟电路驱动】下，从指令寄存器【它存储了用户编写的大量二进制信号】，每来一个脉冲就取一条指令
 * 【有一个程序计数器电路计数】，然后译码，并保存在工作寄存器组，最终送入到逻辑门电路的【ALU】
 *
 * 处理的结果最终是保存在各类寄存器【内存】，其它设备再从内存获取数据
 *
 * 指令：一串二进制，大量的指令构成指令系统，ALU逻辑电路运行后会输出不同的结果
 * 编译：将源码转换为指令【不同的二进制组合，就是数字信号，输入不同的电平，会输出不同的结果】
 *
 * 所有的指令全部经过强大复杂的ALU逻辑运算单元处理【具体里面有上百万的集成逻辑电路构成】
 *
 * 逻辑电路：能进行逻辑运算的电路 如与门电路
 *
 * cpu由时钟电路驱动执行指令，在时钟的上升沿或下降沿执行指令，如果指令占用一个方波
 * 就是单周期指令[一个时钟周期就是一个上升沿到下降沿的过程|---|___高电平变化低电平就是一个时钟周期]
 *
 * 存储器的空间：00000000 000000 ~ffffffff ffffffff=4294967295/1000=4294967kb
 * 4294967kb/1000/4294MB=4G
 *
 * 寄存器：基本寄存器，移位寄存器，由时序逻电路驱动
 *
 *
 * 虚拟地址和物理地址转换--页表
 * 10MB
1M=1024k
1k=1024b
1b=8bit

10*1024*1024*8
1k=1024

1m=1000k
1m=1000000b

8k=1024b

1g-1024m
1m=1024k
1k=1024by

1g=1024*1024*1024

4k=1024b*4

页表转换
4G虚拟内存空间/4k每页大小
1073741824*4/4096=1048576/1024/1024=1M 总为1M个页面，每个页面为4k大小

2*10=1024
2*11=2048

10000  00000000  00000000 二进制
    100000   十六进制
2*20=1M

1048576*4=4M页表[页表数组大小]
 页表数组
 [
 000000000000000000000
 000000000000000000001每个页面的编号*4096=4k
 000000000000000000010第二个页面的编号*4096=8k
 000000000000000000011第三个页面的编号*4096=12k
 000000000000000000100
 000000000000000000101
 ......
 100000000000000000000 最后一个页面*4k=1048576*4k=4294967296b=4294967k=4294M=4G
 ]

 内存分区模型
 linux32位
 程序代码区【存储指令】
 常量区、全局数据区、堆，栈【存储数据】

 程序代码区，常量区，全局数据区，栈区【由操作系统控制分配和释放】  静态内存分配
 堆区[栈区】：程序运行时自动分配和释放，程序员可控制  动态内存分配
 */
struct test{
    int a;
    char b;
    int c;
}t={1,'c',2};
int main(void)
{
//    int a = 10;
//    int b = 20;
//    printf("a=%#X,b=%#X\n",&a,&b);
//    /**
//     * 打印变量的内存地址并不是真的内存物理地址，而是虚拟地址，会由操作系统管理内存完成
//     * 相互切换
//     *
//     * 程序运行时，操作系统会完成虚拟地址和物理的内存映射
//     */

//     //内存地址 对齐
//     printf("%d,%d,%d,%d\n", sizeof(t.a), sizeof(t.b), sizeof(t.c), sizeof(t));
//     printf("%#X,%#X,%#X,%#X\n", &t.a, &t.b, &t.c, &t);
//
//     //变量内存对齐测试
//     int k=0;
//     char m='c';
//     int n=2;
//     printf("%d,%d,%d\n", sizeof(k), sizeof(m), sizeof(n));
//     printf("%#X,%#X,%#X\n",&k,&m,&n);

        char *p = (char *)0XFFF00000FFF00000;//虚拟地址为0XFFF000001 cpu运行时会找到其对应的物理内存
        printf("p=%s\n",p);//打印虚拟地址上的数据
    return 0;
}

